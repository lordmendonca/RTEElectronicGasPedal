

/*
 * Filename: swc_control.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_control.h"



/* USER CODE START SWC_CONTROL_INCLUDE */

#include "intToASCII.h"
#include "watchdog.h"

/* USER CODE END SWC_CONTROL_INCLUDE */


#include "sp_common.h"

/* USER CODE START SWC_CONTROL_USERDEFINITIONS */

/* USER CODE END SWC_CONTROL_USERDEFINITIONS */



/*
* component: swc_control
* cycletime: 0
* description: Runnable for the calculation control.
* events: ev_joystick_onData
* name: CONTROL_calcControl_run
* shortname: calcControl
* signalIN: so_joystick
* signalOUT: so_speed
* task: tsk_control
*/
void CONTROL_calcControl_run(RTE_event ev){
	
	/* USER CODE START CONTROL_calcControl_run */
    
    static SC_SPEED_data_t speedValue = SC_SPEED_INIT_DATA;
    static char asciiConvert[30];
    static RC_t res = RC_SUCCESS;
    /*
     * Updating the Alive Monitoring register. 
     * Bit Position 1 - RUNNABLE_CALCCONTROL
     **/
    WD_Alive(1);
    /**
     * Error Handling
     **/
    if(res != RC_SUCCESS)
    {
        UART_LOG_PutString("Watchdog Status register update failed. \n");   
    }
    
    /**
     * Translating joystick value into speed value as 
     * speed value = 2 x joystick value along positive y-direction (front).
     * speed value = 0 along negative y-direction (back).
     **/
    if(RTE_SC_JOYSTICK_get(&SO_JOYSTICK_signal).Joystick_Y > 0)
    {
        speedValue.speed = 2 * (RTE_SC_JOYSTICK_get(&SO_JOYSTICK_signal).Joystick_Y);
    }
    else
    {
        speedValue.speed = 0;
    }
    
    /**
     * Test Case for alive monitoring.
     * RTE_SC_SPEED_set(..) is when updates the speed also triggers the event 'ev_speed_onData'
     * that invokes the runnable 'BRAKELIGHT_setBrakeLight_run'.
     * However, to test the watchdog timer, the speed is not set and the runnable is not called.
     * Therefore, the 3rd bit of the alive monitoring status register is not set.
     * (Runnable 'BRAKELIGHT_setBrakeLight_run' needs the event 'ev_speed_onData' to execute).
     * Therefore, a watchdog timeout happens and the system restarts after this reset.
     **/
    if(wdt_test != TRUE)
    {
        /**
         * Updates the speed into the speed object.
         **/
        RTE_SC_SPEED_set(&SO_SPEED_signal, speedValue);
        
        /**
         * Display Speed value.
         **/
        UART_LOG_PutString("Speed : ");
        intToASCII((uint32_t)RTE_SC_SPEED_get(&SO_SPEED_signal).speed, (uint8_t*)&asciiConvert, 4);
        UART_LOG_PutString(asciiConvert);
        UART_LOG_PutString("\n");
        
    }
    else
    {
        // if(RTE_SC_SPEED_getAge(&SO_SPEED_signal) >= 2000) -- test case where watchdog timeout does not happen.
        if(RTE_SC_SPEED_getAge(&SO_SPEED_signal) >= 5000) // test case for watchdog timeout
        {
            /**
             * Setting of the speed will continue after 5s.
             * Fails to continue if the watchdog timeout is lesser than 5s as the system will then restart.
             **/
            wdt_test = FALSE;
            UART_LOG_PutString("Watchdog timer did not overflow. \n");   
        }
        else
        {
            UART_LOG_PutString("Watchdog timer testing started ... \n");   
        }
    }

    /* USER CODE END CONTROL_calcControl_run */
}

/* USER CODE START SWC_CONTROL_FUNCTIONS */

/* USER CODE END SWC_CONTROL_FUNCTIONS */

